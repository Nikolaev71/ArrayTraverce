using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WindowsFormsApplication2
{
    public partial class Form1 : Form
    {
        /// <summary>
        /// Глубина
        /// </summary>
        public int y;
        
        /// <summary>
        /// Ширина
        /// </summary>
        public int x;
        
        /// <summary>
        /// Ширина обхода
        /// </summary>
        public int x1;
        
        /// <summary>
        /// Глубина обхода
        /// </summary>
        public int y1;
        
        /// <summary>
        /// Массив исходных значений
        /// </summary>
        public int[,] arr;
        
        /// <summary>
        /// Массив флагов для исходных значений: если ячейку посетили, и она попала в результирующий массив, 
        /// то ей присваивается true, а если ячейка пропущена - то в ней остается false.
        /// Это используется для того, чтобы в конце посчитать кол-во пропущенных ячеек, и сообщить,
        /// были ли при обходе пропущенные ячейки (т.е. те, у которых флаг = false).
        /// </summary>
        public bool[,] visited;

        /// <summary>
        /// флаг прекращения обхода массива
        /// </summary>
        bool stop = false;

        /// <summary>
        /// вспомогательная переменная для итерации по ширине
        /// </summary>
        private int _d = 0;

        /// <summary>
        /// Итерация по ширине
        /// </summary>
        public int d
        {
            get { return _d; }
            set { _d = value; }
        }
        
        /// <summary>
        /// номер строки обхода
        /// </summary>
        int row { get; set; }
        
        /// <summary>
        /// номер столбца обхода
        /// </summary>
        int col { get; set; }
        
        /// <summary>
        /// флаг разворота: если true, то идем по строке справа налево. Иначе читаем слева направо.
        /// </summary>
        bool reverse = false;

        /// <summary>
        /// Отрисовка формы
        /// </summary>
        public Form1()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Обработчик нажатия на кнопку Построить матрицу
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button1_Click(object sender, EventArgs e)
        {
            //Матрица строится в цветной панели panel.
            //Это сделано для того, чтобы вставить полосы прокрутки, если матрица очень большая.
            //Изначально очищаем эту панель.
            panel.Controls.Clear();
            //Создаем панель матрицы
            var sourcePanel = new Panel();
            //Очищаем эту панель. Хотя на ней и так ничего нет =)
            sourcePanel.Controls.Clear();
            //Считываем значения с текстовых полей для глубины и ширины
            y = Convert.ToInt32(textBox1.Text);
            x = Convert.ToInt32(textBox2.Text);
            //создаем массив исходных значений
            arr = new int[y, x];
            //создаем массив значений флагов посещения ячеек исходного массива
            visited = new bool[y, x];
            //первый элемент матрицы
            var a = 1;
            //заполняем матрицу исходных значений
            for (int i = 0; i < y; i++)
            {
                for (int j = 0; j < x; j++)
                {
                    arr[i, j] = a;
                    //для каждой ячейки создаем панель - клетку 40х40
                    var item = new Panel()
                    {
                        Width = 40, //ширина
                        Height = 40, //высота
                        //контур для клетки
                        BorderStyle = BorderStyle.FixedSingle
                    };
                    //создаем надпись для клетки
                    var label = new Label()
                    {
                        Text = arr[i, j].ToString(),
                        //растягиваем надпись на вю клетку
                        Dock = DockStyle.Fill,
                        //выравниваем по центру клетки
                        TextAlign = ContentAlignment.MiddleCenter,
                        //задаем цвет фона
                        BackColor = Color.Azure
                    };
                    //вставляем надпись в панель клетки
                    item.Controls.Add(label);
                    //задаем расположение клетки на панели матрицы
                    item.Location = new Point(j * 40, i * 40);
                    //добавляем клетку на панель матрицы
                    sourcePanel.Controls.Add(item);
                    //растягиваем панель матрицы по ее содержимому
                    sourcePanel.AutoSize = true;
                    //увеличиваем счетчик для записи следующего значения
                    a++;
                }
            }
            //вставляем матрицу исходных значений в цветную панель
            panel.Controls.Add(sourcePanel);
            //задаем расположение
            panel.Controls[0].Location = new Point(0, 0);
            //добавляем полосы прокрутки, если содержимое не умещается
            panel.AutoScroll = true;
            //обновляем панель
            panel.Refresh();
            //отображаем элементы для ввода ширины и глубины обхода
            label3.Visible = true;
            label4.Visible = true;
            label6.Visible = true;
            textBox3.Visible = true;
            textBox4.Visible = true;
            button2.Visible = true;
        }

        /// <summary>
        /// Обработчик нажатия на кнопку Рассчитать обход
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button2_Click(object sender, EventArgs e)
        {
            //нажимаем на кнопку создания матрицы. Это делается для того, чтобы был правильно заполнен исходный массив.
            //Потому что можно забыть нажать на кнопку создания, когда первый расчет уже был произведен, а потом поменяли ширину и глбину исходной матрицы.
            //Можно эту строчку убрать, но тогда не забывать нажимать кнопку для пересоздания матрицы, если исходные данные изменились.
            button1_Click(sender, e);
            //флаг прекращения обхода = false. Мы только начинаем обход.
            stop = false;
            //считываем с текстовых полей значения ширины и глубины обхода
            x1 = Convert.ToInt32(textBox3.Text);
            y1 = Convert.ToInt32(textBox4.Text);
            //задаем начальное значение итерации по ширине обхода
            d = 0;
            //начальное значение столбца обхода
            col = 0;
            //начальное значение флага разворота
            reverse = false;
            //строка результата
            label6.Text = "";
            //создадим флаг, для обозначения, что исходные данные верны
            var correct = true;
            //проверяем значение ширины обхода. 
            //Если она больше 2, и  ширина кратна ей, ИЛИ ширина обхода равна 2, то все верно.
            //Если это не так, выводим сообщение, очищаем поле для ввода ширины обхода, 
            //устанавливаем флаг, что данные неверны.
            if (!((x1 > 2 && (x % x1) == 0) || (x1 == 2)))
            {
                MessageBox.Show("Число столбцов дожно быть кратно ширине обхода.");
                textBox3.Clear();
                correct = false;
            }
            //проверяем значение глубины обхода. 
            //Если она больше 2, и  глубина кратна ей, ИЛИ глубина обхода равна 2, то все верно.
            //Если это не так, выводим сообщение, очищаем поле для ввода глубины обхода, 
            //устанавливаем флаг, что данные неверны.
            if (!((y1 > 2 && (y % y1) == 0) || (y1 == 2)))
            {
                MessageBox.Show("Число строк дожно быть кратно глубине обхода.");
                textBox4.Clear();
                correct = false;
            }
            //если данные неверны, то обход не начинаем.
            if (correct == false)
            {
                return;
            }

            //если мы сюда пришли, то данные верны, можно начинать обход.
            //вычисляем, сколько ячеек в нашей матрице.
            var z = y * x;
            //создаем вектор - результирующий массив. Его максимальный размер равен кол-ву ячеек в матрице.
            int[] res = new int[z];

            //переменная для определения направления обхода. 0 - по строке, 1 - по столбцу.
            var xx = 0;
            //переменная-счетчик. Пока она меньше кол-ва клеток матрицы, продолжаем обход.
            var item = 0;

            //начинаем обход
            do
            {
                //если направление обхода - по строке
                if (xx == 0)
                {
                    //если флаг разворота = false
                    if (reverse == false)
                    {
                        //то идем по строке направо
                        item = RowRight(row, res, item);
                    }
                    else//если флаг разворота = true
                    {
                        //то идем по строке налево
                        item = RowLeft(row, res, item);
                    }
                    //после обхода строки меняем направление обхода на обход по столбцу.
                    xx++;
                }
                else //если обход по столбцу
                {
                    //если строка больше или равна глубине
                    if (row >= y)
                    {
                        //значит дошли до низа, увеличиваем итерацию по ширине 
                        d++;
                        //и переходим наверх
                        row = 0;
                    }
                    else//если не дошли еще до низа
                    {
                        int r = row;
                        //обходим столбец
                        item = Col(row, res, item, col, out r);
                        row = r;
                    }
                    //меняем направление обхода на обход по строке
                    xx--;
                }
            } while (item < z && !stop); //продолжаем, пока не перебрали все клетки и не завершили обход

            //вывод результата
            label6.Text += string.Join(" ", res.Where(o => o != 0).Select(o => o.ToString()));

            //были ли пропуски?
            var bez_propuskov = true;// считаем, что не было пропусков
            for (int i = 0; i < y; i++)
            {
                for (int j = 0; j < x; j++)
                {
                    if (!visited[i, j])
                    {
                        bez_propuskov = false;// нашелся пропуск, хотя бы один
                        break;
                    }
                }
                if (!bez_propuskov)
                {
                    break;
                }
            }
            
            if (bez_propuskov)
            {
                MessageBox.Show("Обход завершен, пропусков нет.");
            }
            else
            {
                MessageBox.Show("Обход завершен, есть пропуски.");
            }
        }

        /// <summary>
        /// Обход по строке слева направо
        /// </summary>
        /// <param name="row">строка обхода</param>
        /// <param name="res">результирующий массив</param>
        /// <param name="item">элемент в результирующем массиве, в который будем записывать значение</param>
        /// <returns>возвращает следующий элемент, куда надо будет записывать значение</returns>
        int RowRight(int row, int[] res, int item)
        {
            //цикл по ширине обхода
            for (int i = 0; i < x1; i++)
            {
                //вычисляем номер столбца в зависимости от итерации по ширине обхода.
                var column = d * x1 + i;
                //если вышли за границы матрицы, то завершаем обход
                if (row >= y || column >= x)
                {
                    stop = true;
                    return item;
                }
                //если не вышли, получаем значение клетки
                var value = arr[row, column];
                //если эта клетка уже была просмотрена, продолжаем цикл.
                if (visited[row, column] == true)
                {
                    continue;
                }
                //если клетка не была еще просмотрена, то записываем значение в результирующий массив
                res[item] = value;
                //и отмечаем клетку как просмотренную
                visited[row, column] = true;
                //будем вычислять следующий элемент
                item++;
            }
            //разворачиваемся
            reverse = true;
            //вычисляем столбец, на котором остановились
            col = (d + 1) * x1 - 1;
            return item;
        }

        /// <summary>
        /// Обход по строке справа налево
        /// </summary>
        /// <param name="row">строка обхода</param>
        /// <param name="res">результирующий массив</param>
        /// <param name="item">элемент в результирующем массиве, в который будем записывать значение</param>
        /// <returns>возвращает следующий элемент, куда надо будет записывать значение</returns>
        int RowLeft(int row, int[] res, int item)
        {
            //цикл по ширине обхода справа налево
            for (int i = x1 - 1; i >= 0; i--)
            {
                //получаем значение клетки
                var value = arr[row, d * x1 + i];
                //если эта клетка уже была просмотрена, продолжаем цикл.
                if (visited[row, d * x1 + i] == true)
                {
                    continue;
                }
                //если клетка не была еще просмотрена, то записываем значение в результирующий массив
                res[item] = value;
                //и отмечаем клетку как просмотренную
                visited[row, d * x1 + i] = true;
                //будем вычислять следующий элемент
                item++;
            }
            //разворачиваемся
            reverse = false;
            //вычисляем столбец, на котором остановились
            col = d * x1;
            return item;
        }

        /// <summary>
        /// Обход по столбцу
        /// </summary>
        /// <param name="row">строка обхода</param>
        /// <param name="res">результирующий массив</param>
        /// <param name="item">элемент в результирующем массиве, в который будем записывать значение</param>
        /// <param name="col">столбец обхода</param>
        /// <param name="r">выходной параметр, возвращает номер строки обхода, на котором закончили обход по столбцу</param>
        /// <returns>возвращает следующий элемент, куда надо будет записывать значение</returns>
        int Col(int row, int[] res, int item, int col, out int r)
        {
            //цикл по глубине обхлда
            for (int i = 0; i < y1; i++)
            {
                //если вышли за пределы массива по строкам
                if (row + i >= y)
                {
                    //стираем значения, которые записали из неполного стобца
                    for (int n = 0; n < i-1; n++)
                    {
                        res[item] = 0;
                        item--;
                    }
                    //переходим на верхнюю строку
                    r = 0;
                    //увеличиваем итерацию по ширине обхода
                    d++;
                    //будем идти слева направо
                    reverse = false;
                    return item;
                }
                //вычисляем значение клетки
                var value = arr[row + i, col];
                //если эта клетка уже была просмотрена, продолжаем цикл.
                if (visited[row + i, col] == true)
                {
                    continue;
                }
                //если клетка не была еще просмотрена, то записываем значение в результирующий массив
                res[item] = value;
                //и отмечаем клетку как просмотренную
                visited[row + i, col] = true;
                //будем вычислять следующий элемент
                item++;
            }
            //вычисляем строку, на которой остановились
            r = row + y1 - 1;
            return item;
        }
    }
}
